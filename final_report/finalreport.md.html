<meta charset="utf-8" emacsmode="-*- markdown -*-">
**Plant Buddy - Final Report**

Having a plant in your life has many benefits. It can help relieve stress, boost creativity, improve productivity, and a bunch of other benefits to one’s well-being and health. Yet, taking care of plants can be difficult. Different types of plants require different amounts of sunlight and water and it can be hard to remember the needs of each specific plant. In addition, life simply can get busy. Sometimes, you might forget to water your plant or forget when the last time you watered your plant was. You might also have left your plant out in the sun for too long, or not long enough. So many things can go wrong which can ultimately and unfortunately cause the plant to die. Don’t you wish there was an easy way to keep track of your plant's needs?

Introducing Plant Buddy, your new assistant in keeping your plants healthy and happy!


![Full Demo Video](https://youtu.be/6G4FIQ_lRlU)

Functionality
===============================================================================
The systems starts in freeplay mode and displays a nice options menu interface to allow the user to change the mode if they want.
We have implemented the following modes: Freeplay Mode, Recording Mode, Song Mode, and Sequencer Mode.

![State Machine Diagram](./images/state_machine.png)

IDLE Mode
-------------------------------------------------------------------------------
Our system’s default state will be this “idle” state where nothing happens if you walk up the stairs/through the pathway. 
We added this just in case people want to turn off the system at night without unplugging the ESP32.

Freeplay Mode
-------------------------------------------------------------------------------
The “free play” mode of the system will detect the user’s steps and as a result, a corresponding frequency will be played on the buzzer. 
We define a "step" as every time the laser beam is broken when a foot is placed between the laser and the phototransistor.  We integrated an LED strip to light up with every step that is taken on the stairs.  In this mode, only the most recently broken laser beam's frequency and light will play.


Multinote Mode
-------------------------------------------------------------------------------
Multinote is able to play multiple notes at once, using 8 distinct buzzers each dedicated to one of the laser/phototransistor pairs on the stairs. Playing notes is done in a similar manner to the other modes, but its capabilities are extended by using arrays.  The array index tracks the stair's corresponding buzzer, phototransistor,  light strip, and the previous note played on this stair to avoid continuously playing the note and flashing the LEDS.

We were unable to integrate this mode with the rest of the system due to power issues.  As a result, this mode is a standalone capability not integrated with AirPiano's freeplay, recording, and sequencer modes.  

![Multinote Separate Functionality](https://youtu.be/cYSi2LqmWaQ)



Recording Mode
-------------------------------------------------------------------------------
![Recording Mode States](./data/recording_mode.png)

The “recording” state will allow a user to record their musical steps and send that to a database where their friends can see the music they made and play it back on the site. 
They first enter the "pre-recording" state where the user reads a description of the mode and must push a button to proceed. Then their sequence of steps and their respective notes will be recorded. The user is able to end the recording when they are satisfied with what they have or the recording will automatically end when the recording buffer is full.
They will then be asked if the are sure they want to send that song to the server. If not, they leave the recording mode. If they do, then they give it a name with the Google Speech API and the second core is utilized to send the song information via HTTP POST request. The user has the chance to rename the song if the API transcribes the incorrect words. Then, by using the second core the user can immediately get back to playing in Free Play without waiting for the ESP32 to POST the recording to the server.

The second core is used to POST recordings by keeping track of a global variable. The recording mode once it has finished recording and naming the song sets this variable to a value of `1`. Subsequently, the second core waits on this value to be `1`, and if it is will post the notes recorded and the name of the song. It will then set the variable back to `0` once it is done. To protect against the possibility of the user entering the Recording Mode again before the second core has recorded the song, there is a check at the start of the Recording Mode to wait until the variable is set to `0`, signaling that the second core is ready to POST another recording.

Song Mode
-------------------------------------------------------------------------------
The song mode allows the user to play a recorded song that was saved to the database. 

The first step is performing a GET request to retrieve the last 5 IDs + song names posted to the server.  The IDs + names are then printed to the tft screen, and the user selects one of the names with the button.  We then perform a second GET request using the ID of the song.  This pulls down the arrays for frequencies and times that each freqency should play for.  We then use these arrays to play the notes on the buzzers, and get the corresponding LEDs to light up.  


Seqeuncer Mode
-------------------------------------------------------------------------------
The sequencer mode allows the user to play along with themselves by playing back the notes in a loop. 
There is a set delay interval between when the user plays a note, and when the additional copy of the note is played again. 
To ensure that there does not end up being a constant amount of notes played such that it sounds bad, the multiple repetitions 
of any note was limited to a constant number. 
Further experimentation on what the exact delay length and the number of repetitions needed to provide the user the ability to improvise with themselves would be helpful.

To record when the notes are played in the loop, the loop length was split into distinct buckets in an array. Currently, there are `500` buckets that a note could be put within. The loop length that was decided to be 2 seconds based on a typical 120 beats per minute giving half a second per quarter note. As there are typically 4 notes to a bar, that gives a bar length of two seconds. Therefore, these 500 buckets evenly divide the space of the two seconds. This gives us enough time resolution with when notes are played by a user and when they actually repeat without sacrificing performance or storage space. 

Along with the array that tracks when frequencies are played, there is also an array that keeps track of how many times the note can repeat before stopping. This is to solve the issue where as a user adds more and more notes to the loop, there is no good current way to remove notes. So currently, all notes will play 7 times before disappearing, allowing room for the user to continue playing new rhythms and notes. An alternative to this solution could have been to dedicate one of the lasers to playing silence, but considering this would have been different from all of the other modes, it would have been unintuitive.

Notification LED
-------------------------------------------------------------------------------
A small function runs on the second core periodically and pings the server with a GET request. This request queries to determine whether new songs have been posted to the server from a different AirPiano from itself in the time period since its last ping. Depending on the number of new songs, the LED will blink green that many times to notify the user to either check the website to see the new songs or enter song mode and play them on their ESP32. This notification provides the user extra ease of use of the system and encourages exploring the songs created by other people.

To ensure that the user will actually notice the LED, its normal state shines red so that it is a stark contrast when the green appears. If only a single song has been posted since the last query, it will linger on the green color for an longer amount of time compared to usual so that the user has a better chance of catching the notification.

The Baker side of the team did not have notification LEDs flashing in their implementation because they did not have any more pins for more LEDs.  However, it is still a fully function implementation if there were more pins available.

AirPiano Server/Website
-------------------------------------------------------------------------------
We were able to utilize the server for GET/POST requests coming from the esp32 in various states. 
We wrote various scripts that would allow us to perform tasks like POSTing song data from the esp32, retrieving recent entries, and retreiving the notes to a specfic song.
Apart from this, we also made a website to accompany our project that featured 2 main pages:

* Home Page - gives user a project overview and allows them to search for a specific song
* Database Page - allows user to see the most recent entries posted to the server and play the songs
* Song Page - a potential page that would allow for future scaling of the project, where users could one day place comments for a specific song
* Meet the Team Page - team member profiles 

Documentation
===============================================================================

Full System Diagram
-------------------------------------------------------------------------------
![Functional Block Diagram](./images/functional_diagram.png)

Hardware Layout
-------------------------------------------------------------------------------


Parts List
-------------------------------------------------------------------------------

Photoresistors

* Cost: From previous labs
* Used for measuring amount of light going through

LCD Screen

* Cost: From previous labs
* Used for: Displaying steps in sampling plant data, and current conditions

Temperature/Pressure Sensor

* Cost: From previous labs
* Used for: Measuring if the current environmental conditions were within range for the plant to be considered in a healthy environment, and not one where it would dry out or get damaged. 

[Soil Moisture Sensor](https://www.sparkfun.com/products/13322 )

* Cost: $6.50
* Used for: Measuring how moist soil was in order to tell whether our plant currently had enough water in its pot. 


Design Challenges and Decisions
-------------------------------------------------------------------------------
Some challenges in this project included:
* understanding and processing sensor readings to sensible and accurate data 
* making ESP32 responsive from button press on website
* implementing a webscraper to scrape ideal conditions on different plants

### Understanding Sensor Readings
text

### Connecting ESP32 with Website
text

### Webscraper
One of the things we wanted for our design was a list in which users could select a plant from. Those plants would already have ideal sunlight, temperature, and moisture levels associated with them, so users didn’t have to manually input it. We planned on doing this by webscraping a plant website, since there were no available APIs that did that. However, webscraping was not taught about in class and nobody on the team knew how to do it. Regardless, we managed to figure it out during the Week 2 Milestone. In the end though, we decided not to use the data from the webscraper and instead we hard coded a few of the most common household plants. There was just too many plants in the database (over 1500) and it lacked temperature ranges for the plant, so we would have had to webscrape another page and join the two together. The soil and moisture readings also were different than how we processed ours, so it just didn’t work out. The webscraper code isn't part of the final code, but can be found below:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import requests
from bs4 import BeautifulSoup
import re
import pandas as pd
import sqlite3

plant_web_db = '/Users/timmydang/downloads/6.08/608-plantbuddy/plant_web.db' 

names_list = []
moisture_list = []
shade_list = []
for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
    URL = 'https://pfaf.org/user/DatabaseSearhResult.aspx?LatinName={web_letter}%'.format(web_letter=letter)
    headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36'}
    page = requests.get(URL, headers=headers)
    soup = BeautifulSoup(page.text, 'html.parser')
    dfs = pd.read_html(page.text)
    info_setup = dfs[1]
    info = info_setup[['Common Name', 'Moisture', 'Shade']].dropna()
    names_list += info['Common Name'][0:len(info['Common Name'])].tolist()
    moisture_list += info['Moisture'][0:len(info['Moisture'])].tolist()
    shade_list += info['Shade'][0:len(info['Shade'])].tolist()

with sqlite3.connect(plant_web_db) as c:
    for i in range(len(names_list)):
        plant = names_list[i]
        sunlight = shade_list[i]
        moisture = moisture_list[i]
        c.execute("""CREATE TABLE IF NOT EXISTS plant_web (plant text, moisture real, sunlight real);""")
        c.execute('''INSERT into plant_web VALUES (?,?,?);''',(plant,sunlight, moisture))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Detailed Code Layout
===============================================================================

ESP32 Side
-------------------------------------------------------------------------------
This figure shows some of the most important parts of our code run on the ESP32:
**********************************************************
*            ESP32-side                                  *
*  .------------------------------.                      *
* |     +-- final.ino              |                     *
* |     +-- support_functions.ino  |                     *
*  '------------------------------'                      *
**********************************************************

### final.ino - GET & POST request


### final.ino - Signal Processing 

### final.ino - Sampling

### support_functions.ino

Support functions for running GET and POST requests on final.ino.


Server Side
-------------------------------------------------------------------------------
This figure shows some of the most important parts of our server side elements:
**********************************************************
*            Server-side                                 *
*  .------------------------------.                      *
* |     +-- server.py              |                     *
* |     +-- plantPage.html         |                     *
* |     +-- plantPage.css          |                     *
* |     +-- plant.db               |                     *
* |     +-- plant_reading.db       |                     *
* |     +-- plant_sampling.db      |                     *
*  '------------------------------'                      *
**********************************************************

### server.py - Selecting a plant type from list 
On our HTML page, users can select a plant from a list containing a few of the most common household plants. When they press submit button on the page, it will send a POST request to the server, collecting information about the user’s email, the plant’s name, and one of the plant types from the list. Depending on the plant type, the sunlight, temperature, and moisture levels will be set. It creates plant.db and plant_sampling.db if it doesn’t exist and then inserts values into the database. The values that are inserted into these databases are specified a few sections below.

### server.py - Adding a new plant type
If a plant the user is looking for is not on the list, users can add a new type by manually inputting plant name, plant type, user email, sunlight intensity, hours of sunlight, ideal temperature, and soil moisture percentage and pressing submit on the HTML page to send a POST request to the server. Adding a new plant type will essentially follows the same procedure as selecting a plant type from a list but in this case the sunlight, temperature, and moisture levels are set by the user instead of automatically being set on the server. 

### server.py - Getting information from an existing plant
Users can get information about an existing plant from plant.db by inputting the plant’s name and user email and then pressing submit. This will send a GET request to the server, which will look into the plant.db database with the plant’s name and user email that was inputted from the HTML page.

### server.py - Starting new sampling period
--text--

### server.py - Plant Logic
There is a function in the server, do_plant_logic, with the parameters plant and user, that compares the inputted values from plant.db with the sensor readings from plant_sampling.db whenever a sampling period is requested. It will return a message about the plant's temperature, sunlight, and moisture depending on the differences between the inputted values and the readings. For temperature, the ideal range is within 5 degrees Celsius. If it’s below that then the message will be “Your plant is too cold! :(“ and if it’s more than that then the message will be “Your plant is too hot! :(“. The other readings follow the same procedure, except the range for sunlight is 500 foot candles hours and the range for moisture is 10 percent. In addition, sunlight is calculated in this function by multiplying sunlight hours (inputted by the user) by sunlight intensity. Low, medium, and high sunlight intensity in our code corresponds to 50, 300, and 750 foot candles, respectively.

### plantPage.html
Contains the HTML code for our page.

### plantPage.css 
Contains Cascading Styling Sheet (CSS) used by our HTML page.

### plant.db 

This database contains information about each plant with the following information:

* `plant`: a name given to the plant manually inputted by the user
* `type`:  type of plant, either manually inputted by the user or selected from a list
* `user`: email of the user manually inputted by the user
* `sunlight_intensity`: the ideal sunlight intensity for the plant, either manually inputted from the user or automatically given if the user selects a plant type from the list
* `sunlight_hours`: the ideal sunlight hours for the plant, either manually inputted from the user or automatically given if the user selects a plant type from the list
* `temperature`: the ideal temperature for the plant, either manually inputted from the user or automatically given if the user selects a plant type from the list
* `moisture`: the ideal moisture for the plant, either manually inputted from the user or automatically given if the user selects a plant type from the list

For example:

| plant |            type            | user |         sunlight_intensity        |            sunlight_hours        |  temperature       |        moisture       |
|:--:|:--------------------------:|:---------------:|:--------------------:|:----------------:|:----------------:|:----------------:|:----------------:|
| Bob |       Fern      |     timmyd@mit.edu    | Low | 10 | 20 | 40 |
| Bobbie | Snake Plant |       alexplantbuddy608@gmail.com      | Medium | 8 | 25 | 40 |

### plant_reading.db  

This database contains information on a plant's current conditions with readings from sensors on the ESP32 side. 

* `plant`: a name given to the plant manually inputted by the user
* `type`:  type of plant, either manually inputted by the user or selected from a list
* `user`: email of the user manually inputted by the user
* `sunlight_reading`: sunlight reading using a sensor sent from ESP32
* `temperature_reading`: temperature reading using a sensor sent from ESP32
* `moisture_reading`, moisture reading using a sensor sent from ESP32

For example:

| plant |            type            | user |         sunlight_reading         |       temperature_reading       | moisture_reading |
|:--:|:--------------------------:|:---------------:|:--------------------:|:----------------:| :----------------:|
| Bob |       Fern      |     timmyd@mit.edu    | 2000 | 23 | 40 |
| Bobbie | Snake Plant |       alexplantbuddy608@gmail.com      | 2000 | 22 | 60 |


### plant_sampling.db   

This database contains information on a plant's name and its user. The ESP32 runs GET requests to the server, checking to see if counter for a plant has changed or not. If it does change, then it runs a sampling period.

* `plant`: a name given to the plant manually inputted by the user
* `user`: email of the user manually inputted by the user
* `counter`: an integer which will be incremented by 1 when sampling period is requested on the website


For example:

| plant |            user            | counter |    
|:--:|:--------------------------:|:---------------:|
| Bob |       timmyd@mit.edu      |     3    | 
| Bobbie | alexplantbuddy608@gmail.com  |       5      | 



Milestone Contributions
===============================================================================


## Week 1

The photoresistor, temperature/pressure sensors, moisture sensor, and other hardware components were wired, which was obviously vital to the functionality of the project. The basic structure of the website and database were separately created, later to be integrated so users could have some way of interacting with the project. The server was also set up, so essentially, week 1 was spent setting up some basic structures that can be built upon and integrated with each other in weeks to come.

![Light, temperature, pressure readings](https://youtu.be/PDcCUV5oT8c)

![Soil moisture readings](https://www.youtube.com/watch?v=KKG90N9vUzo&ab_channel=ErinZhang)

![GET/POST requests between server & ESP32](https://youtu.be/j6oKX4m7e18)

## Week 2

The sensors were connected last week, and this week, they were translated into values with real-life meanings. Then, it was time for integration. The web interface and server were integrated so as to successfully receive and insert data from the user to the database, which was of course important to the actual ability of the system to remember the plants that users entered. To get data on plants (so we can know how a plant should be treated), we scraped a website with plant information and consolidated the data for later use.

![Adjusted light & temperature readings](https://www.youtube.com/watch?v=632qEVmVDZM&ab_channel=ErinZhang)

![Adjusted soil readings part one](https://www.youtube.com/watch?v=088uOUcQEH0&ab_channel=ErinZhang)

![Adjusted soil readings part two](https://youtu.be/M1OA_fDYUh8)

![Webscraper](https://www.youtube.com/watch?v=fWM6FreES1Y&ab_channel=ErinZhang)

![Website POST request](https://www.youtube.com/watch?v=AwYLNxZAfaE&ab_channel=ErinZhang)


## Week 3

This week, the ESP32 state machine was cleaned up to handle situations where there was no plant, as well as monitoring and idle states. The sensor work had been divided previously amongst members, so it was also important to combine that work onto one machine. The web interface was finalized to display current conditions of a plant, and most importantly, the data acquired in the previous week, the server, the database, and the ESP32/sensors were all integrated. We also began to work on a script that would notify users if a plant needed to be watered, moving forward into the real user-catered function of this project.

![Website submission](https://youtu.be/9SpsNbZoTxQ)

![Timmy + Alex](https://www.youtube.com/watch?v=hQt1pPPDmig&ab_channel=Hermonkayshag)

![Website + ESP32 Integration](https://youtu.be/TYxHQJ4rYlI)

## Week 4

To simplify the user experience, we manually categorized the moisture levels. We also manually added some common household plants to the database. More importantly, the website was updated to be more aesthetically pleasing and to start a sampling process after prompting. We added the feature of being able to see how the plant was doing based on a smiley or sad face on the LCD, and finally, confirmed that the project worked on other devices by creating it again on another ESP.

![Sampling for one plant](https://youtu.be/e8ASfosAH7c)

![Sampling for two plants part one](https://youtu.be/I7NWsdkbBCQ)

![Sampling for two plants part two](https://www.youtube.com/watch?v=8KWJfZA8wxo&ab_channel=Hermonkaysha)

![Choosing a plant from the list](https://www.youtube.com/watch?v=1phFPULacB0&ab_channel=Hermonkaysha)

![Switching between plants](https://youtu.be/RDf9pLlycqk)

![LCD Display](https://www.youtube.com/watch?v=WPmBSBvzq24&ab_channel=Hermonkaysha)

Team Members
===============================================================================

* Alex Rice
* Timmy Dang
* Sebastian Garcia
* Hermon Kaysha
* Erin Zhang


<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

